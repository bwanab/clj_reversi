(page "index.html"
      (:require [reversi :as r]
                [goog.async.Delay :as delay]))

(def boardsize 4)
(def new-game (let [g (vec (for [i (range boardsize)] (vec (for [j (range boardsize)] r/emp))))
                   m (dec (/ boardsize 2))
                   b [[[0 0] r/black] [[1 1] r/black] [[0 1] r/white] [[1 0] r/white]]]
               (reduce (fn [board [[r c] v]] (assoc-in board [(+ r m) (+ c m)] v)) g b)))

;;(println newgame)

(defn copy-game [] (vec (for [row new-game] (vec (for [c row] c)))))
(defc game (copy-game))
(defc white-score 2)
(defc black-score 2)
(defc over "")
(defc no-black-move "")

(def indexed (partial map-indexed vector))

(defn game-over []
  (println "white score: " @white-score " black score " @black-score)
  (reset! over (cond (> @white-score @black-score) "White wins!"
                     (> @black-score @white-score) "Black wins!"
                     :else "")))

(defn reset-game! []
  (reset! game (copy-game))
  (reset! no-black-move "")
  (reset! over ""))

(defn compute-score [c]
  (count (filter #(= % c) (flatten @game))))

(defn play! [[i j] c]
  (let [lm (r/find-legal-moves @game c)
        s [i j]
        m (get lm s)
        p (if (= c r/black) r/white r/black)]
    (do
      (if (not (empty? lm))
        (if (not (nil? m))
          (do
            (reset! no-black-move "")
            (swap! game r/update-board (cons s m) c)))
        ;(reset! no-black-move "No black move, white moves if possible")
        (js/alert "No black move, white moves if possible"))
      (.start (goog.async.Delay.
               (fn [] (do
                       (let [mm (r/find-legal-moves @game p)]
                         (if (not (empty? mm))
                           (let [fm (first (r/find-best-move @game mm))]
                             (swap! game r/update-board (cons fm (get mm fm)) p))
                           (if (empty? lm)
                             (game-over))))

                       (reset! white-score (compute-score r/white))
                       (reset! black-score (compute-score r/black))
                       (if (empty? @over)
                         (if (= (+ @white-score @black-score) (* 2 boardsize))
                           (game-over)
                           (if (empty? (r/find-legal-moves @game c))
                             (play! [0 0] r/black))))))
               1000)))))

(html
 (head
  (link :href "css/bootstrap.css" :rel "stylesheet")
  (link :href "css/screen.css" :rel "stylesheet"))
  (body
   (table :class "reversi"
          (loop-tpl :bindings [[i row] (cell= (indexed game))]
                    ( tr (loop-tpl :bindings [[j x] (cell= (indexed row))]
                                   (td :on-click #(play! [@i @j] r/black) (text "~{x}"))))))
   (button :on-click reset-game! "new game")
   (table :class "reversi" (tr (td "white") (td (text "~{white-score}")) (td "black") (td (text "~{black-score}"))))
   (div :class "lead"
        (p (text  "~{over}"))
        (p (text  "~{no-black-move}")))
   ))
